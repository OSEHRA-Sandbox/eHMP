VPRJPR ;SLC/KCM -- Handle RESTful operations for patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PUTPT(ARGS,BODY) ; PUTs patient demographics into the database
 N DEMOG,ERR,PID
 D DECODE^VPRJSON("BODY","DEMOG","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 I $G(DEMOG("uid"))="" D SETERROR^VPRJRER(211) QUIT ""
 S PID=$$UPDPT(.DEMOG) I '$L(PID) QUIT ""
 S DEMOG("pid")=PID
 K BODY
 D ENCODE^VPRJSON("DEMOG","BODY","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 Q "/vpr/"_PID_"/"_$$SAVE^VPRJPS(PID,.BODY)
 ;
UPDPT(PD,PID) ; updates PID indexes, returns PID
 ; TODO -- just make sure that
 ;         the demographics object is parsed for ICN & added or updated if necessary
 ;         the patient count is updated if we are adding the patient
 ;         the proper pid is returned
 ; .PD: patient demographics object (decoded JSON)
 ; PID: optional, passed in if known, empty for new patient
 N UID,DFN,ICN,ICV,NEWPID
 S UID=$G(PD("uid")) I '$L("uid") D SETERROR^VPRJRER(207) Q ""
 S DFN=$$DFN4OBJ("PD"),ICN=$$ICN4OBJ("PD"),ICV=$$ICV4OBJ("PD"),PID=$G(PID)
 ; figure out the PID
 I '$L(PID),$L(ICN) S PID=$G(^VPRPTJ("PID",ICN))
 I '$L(PID),$L(DFN) S PID=$G(^VPRPTJ("PID",DFN))
 I '$L(PID) S NEWPID=1
 S PID=$S($L(PID):PID,$L(DFN):DFN,$L(ICN):ICN,1:$$NXTPID) Q:'$L(PID) ""
 ; check for conflicting ICN's
 N XUID,ROOT,LROOT,XICN,XDFN,DFNS
 S ROOT="urn:va:patient:",LROOT=$L(ROOT)
 S XUID=ROOT F  S XUID=$O(^VPRPT(PID,XUID)) Q:$E(XUID,1,LROOT)'=ROOT  I XUID'=UID D
 . S XICN=$$ICN4OBJ($NA(^VPRPT(PID,XUID)))
 . I $L(ICN),$L(XICN),ICN'=XICN D SETERROR^VPRJRER(205,"ICNs:"_ICN_","_XICN) Q
 I $G(HTTPERR) Q ""
 ;
 L +^VPRPTJ("PID"):2 E  D SETERROR^VPRJRER(502) Q ""
 I $G(NEWPID) D  ; if new PID, update the patient count
 . N PCNT
 . S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 . S ^VPRPTX("count","patient","patient")=PCNT+1
 ; add ICN,DFN and PID to the PID index
 TSTART
 S ^VPRPTJ("PID",PID)=PID
 I $L(ICN) S ^VPRPTJ("PID",ICN)=PID S:PID'=ICN ^VPRPTJ("PID",PID,ICN)=""
 I $L(DFN) S ^VPRPTJ("PID",DFN)=PID S:PID'=DFN ^VPRPTJ("PID",PID,DFN)=""
 I $L(ICV) S ^VPRPTJ("PID",ICV)=PID S ^VPRPTJ("PID",PID,ICV)=""
 TCOMMIT
 L -^VPRPTJ("PID")
 Q PID
 ;
NXTPID() ; Return the next available generated PID
 N PID
 L +^VPRPTJ("PID"):2 E  D SETERROR^VPRJRER(502) Q ""
 S ^VPRPTJ("PID")=$G(^VPRPTJ("PID"))+1,PID=";"_^VPRPTJ("PID")
 L -^VPRPTJ("PID")
 Q PID
 ;
DFN4OBJ(OBJNM) ; Return DFN given object named in OBJNM
 Q $TR($P($G(@OBJNM@("uid")),":",4,5),":",";")
 ;
ICN4OBJ(OBJNM) ; Return ICN given object named in OBJNM
 Q $P($G(@OBJNM@("icn")),"V") ; strip off checksum
 ;
ICV4OBJ(OBJNM) ; Return full ICN (with checksum) from OBJNM
 Q $G(@OBJNM@("icn"))
 ;
PID(ARGS) ; Returns a proper PID for PID or ALIAS
 I '$L($G(ARGS("pid"))) D SETERROR^VPRJRER(211) Q ""
 N PID,I,X
 S PID=""
 F I=1:1:$L(ARGS("pid"),",") S X=$P(ARGS("pid"),",",I) D
 . I $G(X)[":" S X=$TR(X,":",";")
 . S X=$G(^VPRPTJ("PID",$G(X,0)))
 . S PID=PID_$S($L(PID):",",1:"")_X
 I '$L(PID) D SETERROR^VPRJRER(211)
 Q PID
 ;
GETPT(RESULT,ARGS) ; Returns patient demographics
 ;TODO: set this up so that is is returning the "local" demographics rather than the first hit
 I $$UNKARGS^VPRJCU(.ARGS,"pid,icndfn,template") Q
 I $L($G(ARGS("icndfn"))) S ARGS("pid")=ARGS("icndfn")
 N UID,PID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S UID=$O(^VPRPT(PID,"urn:va:patient:")) ; just grab the first for now
 ; TODO: create a patient object that is common across sites
 I $E(UID,1,15)'="urn:va:patient:" D SETERROR^VPRJRER(211) Q
 D QKEY^VPRJPQ(PID,UID)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
PUTOBJ(ARGS,BODY) ; PUTs an object for a patient into the database
 N PID S PID=$$PID(.ARGS) Q:'$L(PID) ""
 Q "/vpr/"_PID_"/"_$$SAVE^VPRJPS(PID,.BODY)
 ;
GETOBJ(RESULT,ARGS) ; gets an object given a UID
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 N TEMPLATE S TEMPLATE=$G(ARGS("template"))
 D QKEY^VPRJPQ(PID,$G(ARGS("uid")),TEMPLATE)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
GETUID(RESULT,ARGS) ; gets an object given a UID only (no PID)
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 I '$L(ARGS("uid")) D SETERROR^VPRJRER(207) Q
 N PID S PID=$O(^VPRPTJ("KEY",ARGS("uid"),""))
 I '$L(PID) D SETERROR^VPRJRER(203) Q
 N TEMPLATE S TEMPLATE=$G(ARGS("template"))
 D QKEY^VPRJPQ(PID,ARGS("uid"),TEMPLATE)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
INDEX(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$D(^VPRMETA("index",INDEX)) D SETERROR^VPRJRER(102,INDEX) Q
 ;
 ; check to see if we can return a cached result
 N HASHSTR,HASHTS,HASH S (HASHSTR,HASHTS,HASH)=""
 S HASHSTR="vpr/index/"_PID_"/"_INDEX_"/"_RANGE_"/"_ORDER_"/"_TEMPLATE_"/"_FILTER
 I $$CACHED(PID,INDEX,HASHSTR,.HASH,.HASHTS) D  Q
 . S RESULT=$NA(^VPRTMP(HASH)),RESULT("pageable")=""
 ;
 ; otherwise prepare cache and do the regular query
 ; ^TMP($J) is killed at the beginning of each request in VPRJREQ
 S ^TMP($J,"query")=HASHSTR,^TMP($J,"timestamp")=HASHTS
 S ^TMP($J,"pid")=PID,^TMP($J,"index")=INDEX,^TMP($J,"hash")=HASH
 S ^TMP($J,"template")=TEMPLATE,^TMP($J,"total")=0
 F IDXPID=1:1:$L(PID,",") D QINDEX^VPRJPQ($P(PID,",",IDXPID),INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CACHED(PID,INDEX,HASHSTR,HASH,HASHTS) ; return TRUE if query cached and the cache is current
 ; .HASH returns the hashed value of HASHSTR
 ; .HASHTS returns the current $H of the index used
 Q:'$L(INDEX) 0  Q:'$L(PID) 0  Q:(PID[",") 0
 N MTHD
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method")) Q:'$L(MTHD) 0
 S HASHTS=$G(^VPRPTI(PID,MTHD,INDEX))
 S HASH=$$HASH^VPRJRUT(HASHSTR)
 I '$D(^VPRTMP(HASH,"query"))!'$D(^VPRTMP(HASH,"timestamp")) Q 0  ; no cached data
 I ^VPRTMP(HASH,"query")'=HASHSTR Q 0    ; hash matched, but not original string
 I ^VPRTMP(HASH,"timestamp")=HASHTS Q 1  ; timestamps match, quit true
 Q 0                                     ; default to no cached data
 ;
LAST(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 F IDXPID=1:1:$L(PID,",") D QLAST^VPRJPQ($P(PID,",",IDXPID),INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
FIND(RESULT,ARGS) ; GET for objects using 'where' criteria
 I $$UNKARGS^VPRJCU(.ARGS,"pid,collection,order,bail,template,filter") Q
 N PID,COLL,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 F IDXPID=1:1:$L(PID,",") D QFIND^VPRJPQ($P(PID,",",IDXPID),COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
COUNT(RESULT,ARGS) ; GET for count of domain objects
 I $$UNKARGS^VPRJCU(.ARGS,"pid,countName") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D QTALLY^VPRJPQ(PID,ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLCOUNT(RESULT,ARGS) ; GET for count of objects across patients
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QCOUNT^VPRJAQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLPID(RESULT,ARGS) ; GET all PID's
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,template") Q
 D QPID^VPRJAQ
 S RESULT=$NA(^TMP($J))
 Q
ALLINDEX(RESULT,ARGS) ; GET for index across patients
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QINDEX^VPRJAQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
ALLFIND(RESULT,ARGS) ; GET using filter across all patients
 I $$UNKARGS^VPRJCU(.ARGS,"collection,order,bail,template,filter") Q
 N COLL,ORDER,BAIL,TEMPLATE,FILTER
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$L(FILTER) D SETERROR^VPRJRER(112) Q
 D QFIND^VPRJAQ(COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CHKSUM(RESULT,ARGS) ; Get checksum for a patient
  N PID,SYSTEM
  S SYSTEM=$G(ARGS("system"))
  S PID=$$PID(.ARGS) Q:'$L(PID)
  D EN^VPRJCRC(.RESULT,SYSTEM,PID)
  Q
DELUID(RESULT,ARGS) ; DELETE an object
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid") Q
 N PID S PID=$G(^VPRPTJ("PID",$G(ARGS("pid"),"none")))
 I '$L(PID) S PID=$O(^VPRPTJ("KEY",ARGS("uid"),""))
 I '$L(PID) D SETERROR^VPRJRER(211) QUIT ""
 D DELETE^VPRJPS(PID,ARGS("uid"))
 S RESULT=$NA(^TMP($J))
 Q
DELCLTN(RESULT,ARGS) ; Delete a collection
 I $$UNKARGS^VPRJCU(.ARGS,"pid,collectionName,system") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D DELCLTN^VPRJPS(PID,$G(ARGS("collectionName")),$G(ARGS("system")))
 S RESULT=""
 Q
DELPT(RESULT,ARGS) ; DELETE a patient
 I $$UNKARGS^VPRJCU(.ARGS,"pid") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D CLEARPT^VPRJPS(PID)
 S RESULT=""
 Q
DELALL(RESULT,ARGS) ; DELETE the entire VPR store
 I $$UNKARGS^VPRJCU(.ARGS,"confirm") Q
 I $G(ARGS("confirm"))'="true" D SETERROR^VPRJRER(405) Q
 D KILLDB^VPRJ2P
 S RESULT=""
 Q
